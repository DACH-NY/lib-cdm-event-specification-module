daml 1.2
module ISDA.CDM.EventBuilder.Termination where

import ISDA.CDM.Impl.Contract.Contract
import ISDA.CDM.Impl.Contract.Payout.ContractualQuantity
import ISDA.CDM.Impl.Event.Event
import ISDA.CDM.Impl.Identifier
import ISDA.CDM.Impl.Utils
import ISDA.CDM.Types.All

-- | Build Termination event
buildTerminationEvent : TerminationSpec -> Event
buildTerminationEvent spec =
  let closedState = ClosedState with
                      state = ClosedStateEnum_Terminated
                      activityDate = spec.base.eventDate
                      effectiveDate = spec.base.effectiveDate
                      lastPaymentDate = None
      quantity = getContractualQuantity spec.contract
      quantityChange = buildQuantityChangePrimitive quantity (Some closedState) spec.contract
      primitive = emptyPrimitiveEvent with quantityChange = [quantityChange], transfer = spec.base.transfer
      lineage = emptyLineage with contractReference = [referenceWithEmptyMeta spec.contract.rosettaKey]
      eventEffect = buildEventEffect primitive

  in Event with
        id = spec.base.id
        rosettaKey = ""
        account = spec.base.account
        action = spec.base.action
        effectiveDate = spec.base.effectiveDate
        eventDate = spec.base.eventDate
        eventEffect = Some eventEffect
        eventIdentifier = spec.base.eventIdentifier
        eventQualifier = Some "Termination"
        functionCall = None
        intent = Some IntentEnum_Termination
        lineage = Some lineage
        messageInformation = spec.base.messageInformation
        party = spec.contract.party
        primitive = primitive
        timestamp = spec.base.timestamp
        eventWorkflow = None

-- | Build PartialTermination event
buildPartialTerminationEvent : PartialTerminationSpec -> Event
buildPartialTerminationEvent spec =
  let quantityChange = buildQuantityChangePrimitive spec.change None spec.contract
      primitive = emptyPrimitiveEvent with quantityChange = [quantityChange], transfer = spec.base.transfer
      lineage = emptyLineage with contractReference = [referenceWithEmptyMeta spec.contract.rosettaKey]
      eventEffect = buildEventEffect primitive

  in Event with
        id = spec.base.id
        rosettaKey = ""
        account = spec.base.account
        action = spec.base.action
        effectiveDate = spec.base.effectiveDate
        eventDate = spec.base.eventDate
        eventEffect = Some eventEffect
        eventIdentifier = spec.base.eventIdentifier
        eventQualifier = Some "PartialTermination"
        functionCall = None
        intent = None
        lineage = Some lineage
        messageInformation = spec.base.messageInformation
        party = spec.contract.party
        primitive = primitive
        timestamp = spec.base.timestamp
        eventWorkflow = None

-- | HIDE
buildQuantityChangePrimitive : [ContractualQuantity] -> Optional ClosedState -> Contract -> QuantityChangePrimitive
buildQuantityChangePrimitive change closedState contract =
  let identifierNew = map increaseVersion contract.contractIdentifier

      quantity = getContractualQuantity contract
      quantityNew = zipWith subtract quantity change

      afterContract = (setContractualQuantity quantityNew contract) with contractIdentifier = identifierNew, closedState

  in QuantityChangePrimitive with
      before = Trade with
        execution = None
        contract = Some contract
      after = Trade with
        execution = None
        contract = Some afterContract
